# 記憶體與暫存器元件說明文件

## 基礎時序元件

### DFF (D型正反器，給定元件)
- **功能**: 1位元時序儲存元件，在時脈邊緣捕捉資料
- **輸入**: in, clock
- **輸出**: out
- **特性**:
  - 在時脈上升緣(或其他指定邊緣)捕捉輸入值
  - 輸出在時脈週期內保持穩定
  - 基本的時序電路構建塊
- **時序圖**:
  ```
  時脈: __|‾‾|__|‾‾|__|‾‾|__
  輸入:  0   1   0   1   0
  輸出:  0   0   1   0   1 (延遲一個時脈)
  ```
- **應用**: 所有時序邏輯電路的基礎元件

### Bit (1位元暫存器)
- **功能**: 可讀寫的1位元儲存單元
- **輸入**: in, load, clock
- **輸出**: out
- **操作**:
  - 當 load=1 且在時脈上升緣時: 儲存 in 值
  - 其他時間: 保持之前儲存的值
- **實現方式**:
  ```
  使用 Mux 和 DFF 組合:
  1. Mux 選擇器:
     - 輸入: 當前輸出(來自DFF)和新的輸入
     - 選擇線: load
     - 當 load=1: 選擇 in
     - 當 load=0: 選擇當前值(保持)
  2. DFF: 儲存選擇的值
  ```
- **邏輯結構**:
  ```
  in ─┬─→ Mux ─→ DFF ─→ out
      │        ↑
  out ┼────────┘
      │
  load─┘
  ```

## 暫存器元件

### Register (16位元暫存器)
- **功能**: 可讀寫的16位元儲存單元
- **輸入**: in[16], load, clock
- **輸出**: out[16]
- **操作**:
  - 當 load=1 且在時脈上升緣時: 儲存整個16位元輸入
  - 其他時間: 保持之前儲存的值
- **實現方式**:
  - 使用16個並聯的 Bit 元件
  - 所有 Bit 共用 load 和 clock 信號
  - 每個 Bit 處理對應的位元
- **結構示意**:
  ```
  in[0],load,clock → Bit0 → out[0]
  in[1],load,clock → Bit1 → out[1]
  ...
  in[15],load,clock → Bit15 → out[15]
  ```
- **應用**: CPU中的通用暫存器、暫存值儲存

## 隨機存取記憶體 (RAM)

### RAM8 (8暫存器 RAM)
- **功能**: 8個16位元暫存器的記憶體模組
- **輸入**: in[16], load, address[3], clock
- **輸出**: out[16]
- **容量**: 8個字組 × 16位元 = 128位元
- **操作**:
  1. **定址**: 根據3位元 address 選擇一個暫存器
  2. **讀取**: 總是輸出選擇的暫存器內容
  3. **寫入**: 當 load=1 且在時脈上升緣時，寫入選擇的暫存器
- **實現方式**:
  ```
  1. 使用8個 Register 元件
  2. 使用 DMux8Way 解碼寫入使能信號
  3. 使用 Mux8Way16 選擇讀出暫存器
  ```
- **結構流程**:
  ```
  寫入路徑:
  load → DMux8Way(由address選擇) → 8個寫入使能信號
  每個使能信號控制一個Register的load輸入
  
  讀取路徑:
  8個Register輸出 → Mux8Way16(由address選擇) → out
  ```

### RAM64 (64暫存器 RAM)
- **功能**: 64個16位元暫存器的記憶體模組
- **輸入**: in[16], load, address[6], clock
- **輸出**: out[16]
- **容量**: 64個字組 × 16位元 = 1024位元 (1Kb)
- **定址**: 使用6位元地址
- **實現方式**:
  - 方法1: 使用64個 Register (不實際)
  - 方法2: 使用8個 RAM8 模組分層建構
- **分層結構**:
  ```
  地址分解:
  address[6] = {高位3位元, 低位3位元}
  高位3位元: 選擇哪個RAM8 (0-7)
  低位3位元: 選擇RAM8內哪個暫存器
  
  使用 DMux8Way 選擇要寫入的RAM8
  使用 Mux8Way16 選擇要讀取的RAM8輸出
  ```

### RAM512 (512暫存器 RAM)
- **功能**: 512個16位元暫存器的記憶體模組
- **輸入**: in[16], load, address[9], clock
- **輸出**: out[16]
- **容量**: 512個字組 × 16位元 = 8192位元 (8Kb)
- **實現方式**: 使用8個 RAM64 模組
- **地址分解**:
  ```
  address[9] = {高位3位元, 低位6位元}
  高位3位元: 選擇哪個RAM64 (0-7)
  低位6位元: 選擇RAM64內哪個暫存器
  ```

### RAM4K (4K暫存器 RAM)
- **功能**: 4096個16位元暫存器的記憶體模組
- **輸入**: in[16], load, address[12], clock
- **輸出**: out[16]
- **容量**: 4096個字組 × 16位元 = 65536位元 (64Kb)
- **實現方式**: 使用8個 RAM512 模組
- **地址分解**:
  ```
  address[12] = {高位3位元, 低位9位元}
  高位3位元: 選擇哪個RAM512 (0-7)
  低位9位元: 選擇RAM512內哪個暫存器
  ```

### RAM16K (16K暫存器 RAM)
- **功能**: 16384個16位元暫存器的記憶體模組
- **輸入**: in[16], load, address[14], clock
- **輸出**: out[16]
- **容量**: 16384個字組 × 16位元 = 262144位元 (256Kb)
- **實現方式**: 使用4個 RAM4K 模組
- **地址分解**:
  ```
  address[14] = {高位2位元, 低位12位元}
  高位2位元: 選擇哪個RAM4K (0-3)
  低位12位元: 選擇RAM4K內哪個暫存器
  ```
- **注意**: 使用 DMux4Way 和 Mux4Way16 進行選擇

## 程式計數器

### PC (16位元程式計數器)
- **功能**: 儲存和下一個指令地址的專用暫存器
- **輸入**: 
  - in[16]: 新的程式計數器值
  - load: 載入新值
  - inc: 遞增計數器
  - reset: 重置為0
  - clock: 時脈信號
- **輸出**: out[16]
- **操作模式** (優先順序: reset > load > inc):
  1. **重置**: 當 reset=1 時，輸出設為0
  2. **載入**: 當 load=1 時，載入 in 值
  3. **遞增**: 當 inc=1 時，當前值加1
  4. **保持**: 否則保持當前值
- **實現方式**:
  ```
  1. 使用 Register 儲存當前值
  2. 使用 Inc16 計算當前值+1
  3. 使用 Mux16 多路選擇器決定下一個值:
     輸入0: 當前值 (保持)
     輸入1: 當前值+1 (遞增)
     輸入2: in (載入)
     輸入3: 0 (重置)
  4. 控制邏輯根據 load/inc/reset 產生選擇信號
  ```
- **控制邏輯**:
  ```
  sel[2] 選擇信號:
  if reset: sel = 11 (選擇0)
  else if load: sel = 10 (選擇in)
  else if inc: sel = 01 (選擇當前值+1)
  else: sel = 00 (選擇當前值)
  ```
- **應用**: 在CPU中用於追蹤指令執行位置

## 記憶體階層架構

```
基礎元件:
DFF (1位元時序儲存)
  ↓
Bit (1位元可載入暫存器)
  ↓
Register (16位元暫存器)

記憶體階層:
Register (1字組)
  ↓
RAM8 (8字組) = 8×Register
  ↓
RAM64 (64字組) = 8×RAM8
  ↓
RAM512 (512字組) = 8×RAM64
  ↓
RAM4K (4K字組) = 8×RAM512
  ↓
RAM16K (16K字組) = 4×RAM4K

特殊暫存器:
PC (程式計數器) = Register + 控制邏輯 + Inc16
```

## 時序與同步設計

### 時脈域設計原則:
1. **同步設計**: 所有狀態變化發生在時脈邊緣
2. **建立時間與保持時間**: DFF 的時序要求
3. **時脈偏移管理**: 大規模記憶體中的挑戰

### 讀寫時序:
- **寫入**: 需要 load=1 且在時脈上升緣
- **讀取**: 組合邏輯，立即輸出選擇的地址內容
- **關鍵路徑**: 地址解碼 → 多路選擇器的傳播延遲

## 效能與最佳化考量

### 容量擴展策略:
1. **位元擴展**: 增加字組寬度 (使用更多並聯暫存器)
2. **深度擴展**: 增加地址空間 (使用分層解碼)

### 存取時間最佳化:
- **解碼器樹平衡**: 最小化關鍵路徑
- **分段定址**: 減少選擇器扇出
- **管線化設計**: 提高時脈頻率

### 面積效率:
- **共享解碼邏輯**: 減少重複電路
- **模組化設計**: 重用較小記憶體模組


## 參考資源

*   [nand2tetris](https://drive.google.com/file/d/1CITliwTJzq19ibBF5EeuNBZ3MJ01dKoI/view)
*   [deepseek對話網址](https://chat.deepseek.com/share/m54iatez0yxczupw5q)

